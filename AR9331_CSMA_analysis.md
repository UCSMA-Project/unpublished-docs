# AR9331 CSMA Procedure
In this document I present my analysis of the AR9331 CSMA procedure, this analysis may generally apply to all ath9k based wireless adapters.
## AR9331 CSMA Flowchart
![alt text](https://docs.google.com/drawings/d/1x34OlYx0SNjSsB6Oq-Wj-8msWTR4ZGVpZn-CoRxuvNE/pub?w=1281&h=824 "AR9331 CSMA Flowchart")
## Calculate timing for intercepting transmission
The above CSMA flowchart indicates that if the channel is idle all the time, when the ath9k driver pushes a frame into the hardware buffer, the adapter will start to transmit it immediately. This enables me to calculate the timing for setting FORCE_QUIET_COLLISION bit and intercepting the transmission.
## Violation of the 802.11e Standard
It appears to me that the AR9331 wireless chip doesn't follow strictly to the CSMA procedure described in [the EDCF paper](http://www.cs.jhu.edu/~baruch/RESEARCH/Research_areas/Wireless/wireless-public_html/class-papers/802.11e-performance.pdf). In the pre-frame backoff stage, it appears the AR9331 wireless adapter doesn't use AIFS value at all. According to this experiment ([Busy Channel before New Frame](https://gist.github.com/JackWindows/c7921b76ebc6f3f960b3a2a867435637#experiment-1-busy-channel-before-new-frame)), if the new frame arrives at an idle channel, the adapter will transmit it immediately, regardless of whether the channel has been idle for >AIFS period before the frame arrives. And according to this experiment ([Busy Channel when New Frame Arrives](https://gist.github.com/JackWindows/c7921b76ebc6f3f960b3a2a867435637#experiment-2-busy-channel-when-new-frame-arrives)), if the new frame arrives at a busy channel, the adapter only waits for backoff value until transmitting, and completely ignores AIFS value.
### Experiment 1: Busy Channel before New Frame
In this experiment, I set FORCE_QUIET_COLLISION bit for certain duration before writing TX start register to the adapter, which emulates a busy channel just before a new frame arrives. Then I record the time it takes between writing TX start register and TX_OK interrupt, compare results under different AIFS values and slottime. The code of this patch is [here](https://github.com/JackWindows/OpenWRT-14.07-JS9331/commit/6556eea24fa8d194c2b3131dd4e8537d9cbebd70). Â 
![alt-text](https://docs.google.com/drawings/d/1Qea85uI3_7BOh1ncUpT_IHd_u6mnEfDuf7os3QQTo1c/pub?w=942&h=287 "Busy Channel before New Frame")  
I have used AIFS value from 0 to 30, and slottime from 20us to 100us, however, the recorded duration is fixed around 980us, indicating that the adapter never requires the channel to be idle for >AIFS period when new frame arrives, it always transmits the new frame immediately if the channel is idle when the frame arrives.
### Experiment 2: Busy Channel when New Frame Arrives
This experiment is pretty much similar to the previous one, only that I clear FORCE_QUIET_COLLISION bit immediately after writting TX start register, which emluates a busy channel when the new frame arrives. The code of this patch is [here](https://github.com/JackWindows/OpenWRT-14.07-JS9331/commit/3fa9bac4cb48f204d74dfa5434ec42a6f11f683a).  
![alt-text](https://docs.google.com/drawings/d/1s-rWsBwAXjsjcBv8Vq2KQ4Sq3rladNQbmw0D9AaH4YA/pub?w=942&h=287 "Busy Channel before New Frame")  
First I fixed Contention Window to 0, slottime to 20us, and change AIFS values. I have tried AIFS value from 0 to 30, and the recorded duration is always fixed around 1000us. This indicates that AIFS is not taken into consideration at all for the pre-frame backoff.  
Secondly I fixed AIFS to 0, slottime to 20us, and try different value of Contention Window. I immediately notice that the recorded duartion varies by different value of Contention Winodw, indicating that CW is taken into consideration.   
Thirdly I fixed CW to 0, AIFS to 0, and try slottime of 20us and 100us. The result shows that the recorded duration becomes longer with 100us slottime, and it is roughly 80us longer than the 20us slottime, indicating the adapter always backs off for one slottime following a busy channel event when a new frame arrives.   
Fourthly I fixed CW to 1, AIFS to 0 and slottime to 100us. The recorded duration varies between 1060~1180us, indicating the backoff value is randomly selected between 1 and 2 (0 + 1 and 1 + 1, from the 3rd observation I learnt that the adapter always backs off for 1 additional slottime).